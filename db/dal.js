#!/usr/bin/node
const logger = require('logger').get('dal');
const db = require('./db-connect');

// cassandra-driver:
// https://docs.datastax.com/en/developer/nodejs-driver/4.6/api/class.Client/

class Schema {
	constructor(name, keys = [], immutables = [], automatics = [], validators = []) {
		// e.g. 'guild'
		this.name = name;
		// list of all column names
		this.keys = keys;
		// list of all columns whose values are immutable once a row has
		// been written
		this.immutables = immutables;
		// list of all columns whose values are generated by code in this
		// file, rather than supplied by the user/other areas of the
		// application
		// (e.g. snowflakes are generated here when a record is created)
		this.automatics = automatics;
		// list of functions that validate a schema
		// each function takes an object (proposed record) and a boolean
		// (whether to treat the object as a new record or a set of updates)
		// if the object is treated as a set of updates, some fields may be
		// omitted, whereas a new record must have all fields specified
		// (unless the record is okay with leaving things empty)
		// each function returns an array of zero or more strings, each of
		// which describes an error with the input
		this.validators = validators;
	}

	get isValid() {
		return this.validate().length === 0;
	}

	validate(obj, isUpdate = false) {
		let errors = [];
		this.validators.forEach(v => {
			errors = errors.concat(v(obj, isUpdate));
		});
		return errors;
	}

	// Returns a validator (as described above) that determines whether
	// the given key is present in an object. By default, this only checks
	// when the object is being validated as a new record. When the option
	// requireForUpdates is true, this also checks when the object is being
	// validated as an update.
	// Most of this applies to the next several methods as well, though
	// they vary in what exactly is checked.
	static requirePresence(name, requireForUpdates = false) {
		return (obj, isUpdate) => {
			if (isUpdate & !requireForUpdates) return [];
			if (Object.keys(obj).includes(name)) return [];
			return [`Key ${name} is required, but was not provided`];
		};
	}
	static requireNotNull(name, requireForUpdates = false) {
		return (obj, isUpdate) => {
			if (isUpdate & !requireForUpdates) return [];
			let abort = Schema.requirePresence(name, requireForUpdates)(obj, isUpdate);
			if (abort.length) return abort; // give up if it's undefined

			// actual logic
			if (obj[name] !== null) return [];
			return [`Key ${name} must not be null, but null was provided`];
		};
	}
	static requireType(name, typeSample, requireForUpdates = false) {
		return (obj, isUpdate) => {
			if (isUpdate & !requireForUpdates) return [];
			let abort = Schema.requireNotNull(name, requireForUpdates)(obj, isUpdate);
			if (abort.length) return abort; // give up if it's undefined or null

			// actual logic
			if (obj[name].constructor.name === typeSample.constructor.name) return [];
			return [`Key ${name} must have the type ${typeSample.constructor.name}, but ${obj[name]} of type ${obj[name].constructor.name} was provided`];
		};
	}
}

const schemas = {
	guild: new Schema('guild'
		, ['guild_id', 'name', 'icon_id']
		, ['guild_id']
		, ['guild_id']
		, [
			Schema.requireType('guild_id', 0, true)
			, Schema.requireType('name', '')
			, Schema.requireType('icon_id', 0)
		]
	)
};

// filters an object to only contain valid values according to a schema
const obj2schema = (obj, schema) => {
	const out = {};
	Object.keys(schema).forEach(key => {
		// if the key is present
		if (Object.keys(obj).includes(key))
			// and of the same type as the schema
			if (obj[key] !== null && obj[key].constructor.name === schema[key].constructor.name)
				// then we'll allow it
				out[key] = obj[key];
	});
	return out;
};

// converts an object to an UPDATE-compatible string and an array of parameters
const obj2update = (obj) => {
	if (Object.keys(obj).length === 0)
		throw new Error('No valid changes were supplied');
	const params = [];
	return {
		string: Object.keys(obj).map(key => {
			params.push(obj[key]);
			return key + ' = ?'}).join(', '),
		params
	};
};

// returns description of guild, or throws
const createGuild = async (name, icon_snowflake) => {
	// FIXME generate real snowflakes
	const guild_snowflake = Math.round(Math.random() * 10000000);
	return db.execute(
		'INSERT INTO guilds (guild_id, name, icon) VALUES (?, ?, ?);',
		[guild_snowflake, name, icon_snowflake],
		{ prepare: true }
	).then(() => { return {
		guild_id: guild_snowflake,
		name,
		icon: icon_snowflake
	}});
};

// returns list of guild descriptions, or throws
const getGuilds = async (options) => {
	db.execute(
		'SELECT * FROM guilds;',
		[],
		{ prepare: true }
	).then(res => res.rows);
};

// returns the changes applied, or throws
const updateGuild = async (guild_id, options) => {
	// validate keys
	if (!guild_id) throw new Error('guild_id must be supplied, but was not');

	// validate changes
	const changes = obj2schema(options, schemas.guild);
	const input = obj2update(changes);
	if (!input) throw new Error('No valid changes were supplied');

	// perform update
	input.params.push(guild_id);
	return db.execute(
		'UPDATE guilds SET ' + input.string + ' WHERE guild_id = ?',
		input.params,
		{ prepare: true }
	).then(() => Object.assign(changes, {guild_id}));
};

// returns true or throws
const deleteGuild = async (guild_snowflake) => {
	return db.execute(
		'DELETE FROM guilds WHERE guild_id = ?',
		[guild_snowflake],
		{ prepare: true }
	).then(() => true);
};

module.exports = {
	createGuild, getGuilds, updateGuild, deleteGuild, Schema, schemas
};
